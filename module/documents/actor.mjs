import { clamp } from "../helpers/common-foundry-tasks.mjs";
import { erpsRollHandler } from "../helpers/roll-dice.mjs";
import { restoreMessage } from "../helpers/system-messages.mjs";

/**
 * Actor class for the Eventide RP System
 * @extends {Actor}
 * @class
 * @classdesc Represents an actor in the Eventide RP System, extending the base Foundry VTT Actor class.
 * This class handles character data preparation, roll handling, and resource management.
 * @property {Object} system - The actor's system data
 * @property {Object} flags - Actor-specific flags
 * @property {Collection} items - The actor's items collection
 * @property {Collection} effects - The actor's effects collection
 */
export class EventideRpSystemActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    const flags = actorData.flags.eventiderpsystem || {};
  }

  /**
   *
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic
   * approach is useful when you have actors & items that share a parent Document,
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
  }

  /**
   * Convert the actor document to a plain object.
   *
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   *
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = { ...this };

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

  addResolve(value) {
    this.update({
      "system.resolve.value": clamp(
        this.system.resolve.value + value,
        0,
        this.system.resolve.max
      ),
    });
  }

  addPower(value) {
    this.update({
      "system.power.value": clamp(
        this.system.power.value + value,
        0,
        this.system.power.max
      ),
    });
  }

  async damageResolve({
    formula = "1",
    label = "Damage",
    description = "",
    type = "damage",
    critAllowed = false,
    acCheck = false,
  }) {
    const rollData = {
      formula,
      label,
      type,
      critAllowed,
      description,
      acCheck,
    };
    const roll = await erpsRollHandler.handleRoll(rollData, this);

    // Only apply damage if user has permission
    if (this.isOwner) {
      // Apply damage to resolve.
      if (type === "heal") {
        this.addResolve(Math.abs(roll.total));
      } else {
        this.addResolve(-Math.abs(roll.total));
      }
    }

    return roll;
  }

  /**
   * Generate a roll formula string for an ability roll.
   *
   * @param {Object} params - Parameters for the ability roll.
   * @param {string} params.ability - The ability to roll.
   * @returns {string} The roll formula string.
   */
  async getRollFormula({ ability }) {
    const actorRollData = this.getRollData();
    const diceAdjustments = actorRollData.abilities[ability].diceAdjustments;
    const total = diceAdjustments.total;
    const absTotal = Math.abs(total);
    const rolltype = diceAdjustments.mode;

    if (ability === "unaugmented")
      return `1d${actorRollData.hiddenAbilities.dice.total}`;

    return `${absTotal + 1}d${
      actorRollData.hiddenAbilities.dice.total
    }${rolltype} + ${actorRollData.abilities[ability].total}`;
  }

  /**
   * Get the roll formulas for the actor's abilities.
   *
   * @returns {Object} An object with ability keys mapped to their roll formulas
   * @example
   * // Returns something like: { acro: "2d20k + 5", phys: "1d20 + 3", ... }
   * const formulas = await actor.getRollFormulas();
   */
  async getRollFormulas() {
    const formulas = await Promise.all(
      Object.keys(CONFIG.EVENTIDE_RP_SYSTEM.abilities).map((ability) =>
        this.getRollFormula({ ability })
      )
    );

    return Object.fromEntries(
      Object.keys(CONFIG.EVENTIDE_RP_SYSTEM.abilities).map((ability, index) => [
        ability,
        formulas[index],
      ])
    );
  }

  /**
   * Rolls an ability check for the actor with optional advantage or disadvantage.
   *
   * @param {Object} params - Parameters for the ability roll.
   * @param {string} params.ability - The ability to roll.
   */
  async rollAbility({ ability }) {
    const actorRollData = this.getRollData();
    const formula = await this.getRollFormula({ ability });

    const rollData = {
      formula,
      label: `${actorRollData.abilities[ability].label}`,
      type: ability,
    };

    return await erpsRollHandler.handleRoll(rollData, this);
  }

  /**
   * Restores the actor's resources and removes status effects.
   *
   * This function can restore the actor's resolve and power to their maximum values.
   * It can also remove specific status effects or all status effects from the actor.
   * Only Game Masters can use this function.
   *
   * @param {Object} options - The restoration options
   * @param {boolean} options.resolve - Whether to restore resolve to maximum
   * @param {boolean} options.power - Whether to restore power to maximum
   * @param {Array} options.statuses - Array of status effects to be removed
   * @param {boolean} options.all - Whether to remove all status effects
   * @returns {Promise<ChatMessage|null>} The message detailing the restoration process, or null if not GM
   */
  async restore({ resolve, power, statuses, all }) {
    if (!game.user.isGM) {
      ui.notifications.warn(
        game.i18n.format("EVENTIDE_RP_SYSTEM.Errors.GMOnly")
      );
      return null;
    }

    const statusArray =
      statuses?.length && !all
        ? Array.from(statuses)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : all
        ? Array.from(this.items)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : [];

    if (resolve) this.addResolve(this.system.resolve.max || 0);
    if (power) this.addPower(this.system.power.max || 0);

    if (statusArray && statusArray.length > 0) {
      const statusIds = Array.from(this.items)
        .filter((i) => i.type === "status" && statusArray.includes(i.id))
        .map((i) => i.id);

      await this.deleteEmbeddedDocuments("Item", statusIds);
    }

    return await restoreMessage({
      all,
      resolve,
      power,
      statuses: statuses
        ? Array.from(statuses).filter((i) => i.type === "status")
        : [],
      actor: this,
    });
  }
}
