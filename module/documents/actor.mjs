import { erpsRollHandler } from "../helpers/roll-dice.mjs";
import { erpsMessageHandler } from "../helpers/system-messages.mjs";

/**
 * Actor class for the Eventide RP System
 * @extends {Actor}
 * @class
 * @classdesc Represents an actor in the Eventide RP System, extending the base Foundry VTT Actor class.
 * This class handles character data preparation, roll handling, and resource management.
 * @property {Object} system - The actor's system data
 * @property {Object} flags - Actor-specific flags
 * @property {Collection} items - The actor's items collection
 * @property {Collection} effects - The actor's effects collection
 */
export class EventideRpSystemActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    const flags =
      foundry.utils.getProperty(actorData.flags, "eventide-rp-system") || {};
  }

  /**
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic
   * approach is useful when you have actors & items that share a parent Document,
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
  }

  /**
   * Convert the actor document to a plain object.
   *
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   *
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = { ...this };

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

  /**
   * Apply a transformation to the actor, changing the token appearance
   * @param {Item} transformationItem - The transformation item to apply
   * @returns {Promise<Actor>} This actor after the update
   */
  async applyTransformation(transformationItem) {
    if (!this.isOwner) {
      ui.notifications.warn(
        game.i18n.format("EVENTIDE_RP_SYSTEM.Errors.NoPermission")
      );
      return this;
    }

    if (transformationItem.type !== "transformation") {
      ui.notifications.error(
        game.i18n.format("EVENTIDE_RP_SYSTEM.Errors.NotTransformation")
      );
      return this;
    }

    // Get all tokens linked to this actor
    const tokens = this.getActiveTokens();
    if (!tokens.length) return this;

    // Check if there's already an active transformation
    const hasActiveTransformation = this.getFlag(
      "eventide-rp-system",
      "activeTransformation"
    );

    // Only store original token data if there isn't already a transformation active
    // This ensures we maintain the original appearance, not the appearance of a previous transformation
    if (!hasActiveTransformation) {
      // Store original token data in flags
      const originalTokenData = tokens.map((token) => {
        return {
          tokenId: token.id,
          img: token.document.texture.src,
          scale: token.document.texture.scaleX,
          width: token.document.width,
          height: token.document.height,
        };
      });

      // Set flag with original token data
      await this.setFlag(
        "eventide-rp-system",
        "originalTokenData",
        originalTokenData
      );
    }

    // Set flags with active transformation ID and name
    await this.setFlag(
      "eventide-rp-system",
      "activeTransformation",
      transformationItem.id
    );
    await this.setFlag(
      "eventide-rp-system",
      "activeTransformationName",
      transformationItem.name
    );

    // set flag for cursed
    await this.setFlag(
      "eventide-rp-system",
      "activeTransformationCursed",
      transformationItem.system.cursed
    );

    // Update tokens with the transformation appearance
    for (const token of tokens) {
      const updates = {};

      // Update token image if provided
      if (transformationItem.system.tokenImage) {
        updates["texture.src"] = transformationItem.system.tokenImage;
      }

      // Calculate size and scale based on the transformation size
      if (transformationItem.system.size !== 1) {
        const size = transformationItem.system.size;
        const isHalfIncrement = (size * 10) % 10 === 5; // Check if it's a .5 increment
        const baseSize = Math.floor(size);

        if (size === 0.5) {
          // a 'tiny' creature
          updates.width = 0.5;
          updates.height = 0.5;
          updates["texture.scaleX"] = 1;
          updates["texture.scaleY"] = 1;
        } else if (size === 0.75) {
          // a 'small' creature
          updates.width = 1;
          updates.height = 1;
          updates["texture.scaleX"] = 0.75;
          updates["texture.scaleY"] = 0.75;
        } else {
          updates.width = baseSize;
          updates.height = baseSize;
          if (isHalfIncrement) {
            const scale = 1 + 0.5 / baseSize;
            updates["texture.scaleX"] = scale;
            updates["texture.scaleY"] = scale;
          } else {
            updates["texture.scaleX"] = 1;
            updates["texture.scaleY"] = 1;
          }
        }
      }

      // Apply updates if we have any
      if (Object.keys(updates).length > 0) {
        await token.document.update(updates);
      }
    }

    // Create a chat message about the transformation
    await erpsMessageHandler.createTransformationMessage({
      actor: this,
      transformation: transformationItem,
      isApplying: true,
    });

    return this;
  }

  /**
   * Remove the active transformation from the actor, restoring the original token
   * @returns {Promise<Actor>} This actor after the update
   */
  async removeTransformation() {
    if (!this.isOwner) {
      ui.notifications.warn(
        game.i18n.format("EVENTIDE_RP_SYSTEM.Errors.NoPermission")
      );
      return this;
    }

    // Get the active transformation ID
    const transformationId = this.getFlag(
      "eventide-rp-system",
      "activeTransformation"
    );
    if (!transformationId) return this; // No active transformation

    // Get the transformation item: we cannot get from id because it gets a new one when applied
    let transformationItem = this.items.filter(
      (item) => item.type === "transformation"
    )[0];

    // Get the original token data
    const originalTokenData = this.getFlag(
      "eventide-rp-system",
      "originalTokenData"
    );
    if (!originalTokenData) return this;

    // Get all tokens linked to this actor
    const tokens = this.getActiveTokens();
    if (!tokens.length) return this;

    // Create a chat message about the transformation being removed
    if (transformationItem) {
      await erpsMessageHandler.createTransformationMessage({
        actor: this,
        transformation: transformationItem,
        isApplying: false,
      });
    }

    // remove all transformation items
    for (const item of this.items) {
      if (item.type === "transformation") {
        await this.deleteEmbeddedDocuments("Item", [item.id]);
      }
    }

    // Restore original token data
    for (const token of tokens) {
      const originalData = originalTokenData.find(
        (d) => d.tokenId === token.id
      );
      if (!originalData) continue;

      await token.document.update({
        "texture.src": originalData.img,
        "texture.scaleX": originalData.scale,
        "texture.scaleY": originalData.scale,
        width: originalData.width,
        height: originalData.height,
      });
    }

    // Clear the flags
    await this.unsetFlag("eventide-rp-system", "originalTokenData");
    await this.unsetFlag("eventide-rp-system", "activeTransformation");
    await this.unsetFlag("eventide-rp-system", "activeTransformationName");
    await this.unsetFlag("eventide-rp-system", "activeTransformationCursed");

    return this;
  }

  addResolve(value) {
    this.update({
      "system.resolve.value": erps.utils.clamp(
        this.system.resolve.value + value,
        0,
        this.system.resolve.max
      ),
    });
  }

  addPower(value) {
    this.update({
      "system.power.value": erps.utils.clamp(
        this.system.power.value + value,
        0,
        this.system.power.max
      ),
    });
  }

  async damageResolve({
    formula = "1",
    label = "Damage",
    description = "",
    type = "damage",
    critAllowed = false,
    acCheck = false,
    soundKey = null,
  }) {
    const rollData = {
      formula,
      label,
      type,
      critAllowed,
      description,
      acCheck,
      soundKey,
    };
    const roll = await erpsRollHandler.handleRoll(rollData, this);

    // Only apply damage if user has permission
    if (this.isOwner) {
      // Apply damage to resolve.
      if (type === "heal") {
        this.addResolve(Math.abs(roll.total));
      } else {
        this.addResolve(-Math.abs(roll.total));
      }
    }

    return roll;
  }

  /**
   * Generate a roll formula string for an ability roll.
   *
   * @param {Object} params - Parameters for the ability roll.
   * @param {string} params.ability - The ability to roll.
   * @returns {string} The roll formula string.
   */
  async getRollFormula({ ability }) {
    const actorRollData = this.getRollData();
    const diceAdjustments = actorRollData.abilities[ability].diceAdjustments;
    const total = diceAdjustments.total;
    const absTotal = Math.abs(total);
    const rolltype = diceAdjustments.mode;

    if (ability === "unaugmented")
      return `1d${actorRollData.hiddenAbilities.dice.total}`;

    return `${absTotal + 1}d${
      actorRollData.hiddenAbilities.dice.total
    }${rolltype} + ${actorRollData.abilities[ability].total}`;
  }

  /**
   * Get the roll formulas for the actor's abilities.
   *
   * @returns {Object} An object with ability keys mapped to their roll formulas
   * @example
   * // Returns something like: { acro: "2d20k + 5", phys: "1d20 + 3", ... }
   * const formulas = await actor.getRollFormulas();
   */
  async getRollFormulas() {
    const formulas = await Promise.all(
      Object.keys(CONFIG.EVENTIDE_RP_SYSTEM.abilities).map((ability) =>
        this.getRollFormula({ ability })
      )
    );

    return Object.fromEntries(
      Object.keys(CONFIG.EVENTIDE_RP_SYSTEM.abilities).map((ability, index) => [
        ability,
        formulas[index],
      ])
    );
  }

  /**
   * Rolls an ability check for the actor with optional advantage or disadvantage.
   *
   * @param {Object} params - Parameters for the ability roll.
   * @param {string} params.ability - The ability to roll.
   */
  async rollAbility({ ability }) {
    const actorRollData = this.getRollData();
    const formula = await this.getRollFormula({ ability });

    const rollData = {
      formula,
      label: `${actorRollData.abilities[ability].label}`,
      type: ability,
    };

    return await erpsRollHandler.handleRoll(rollData, this);
  }

  /**
   * Restores the actor's resources and removes status effects.
   *
   * This function can restore the actor's resolve and power to their maximum values.
   * It can also remove specific status effects or all status effects from the actor.
   * Only Game Masters can use this function.
   *
   * @param {Object} options - The restoration options
   * @param {boolean} options.resolve - Whether to restore resolve to maximum
   * @param {boolean} options.power - Whether to restore power to maximum
   * @param {Array} options.statuses - Array of status effects to be removed
   * @param {boolean} options.all - Whether to remove all status effects
   * @returns {Promise<ChatMessage|null>} The message detailing the restoration process, or null if not GM
   */
  async restore({ resolve, power, statuses, all }) {
    if (!game.user.isGM) {
      ui.notifications.warn(
        game.i18n.format("EVENTIDE_RP_SYSTEM.Errors.GMOnly")
      );
      return null;
    }

    const statusArray =
      statuses?.length && !all
        ? Array.from(statuses)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : all
        ? Array.from(this.items)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : [];

    if (resolve) this.addResolve(this.system.resolve.max || 0);
    if (power) this.addPower(this.system.power.max || 0);

    if (statusArray && statusArray.length > 0) {
      const statusIds = Array.from(this.items)
        .filter((i) => i.type === "status" && statusArray.includes(i.id))
        .map((i) => i.id);

      await this.deleteEmbeddedDocuments("Item", statusIds);
    }

    return await erpsMessageHandler.createRestoreMessage({
      all,
      resolve,
      power,
      statuses: statuses
        ? Array.from(statuses).filter((i) => i.type === "status")
        : [],
      actor: this,
    });
  }
}
