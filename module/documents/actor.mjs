import { clamp } from "../helpers/common-foundry-tasks.mjs";
import { rollHandler } from "../helpers/roll-dice.mjs";
import { restoreMessage } from "../helpers/system-messages.mjs";

/**
 * Actor class for the Eventide RP System
 * @extends {Actor}
 * @class
 * @classdesc Represents an actor in the Eventide RP System, extending the base Foundry VTT Actor class.
 * This class handles character data preparation, roll handling, and resource management.
 * @property {Object} system - The actor's system data
 * @property {Object} flags - Actor-specific flags
 * @property {Collection} items - The actor's items collection
 * @property {Collection} effects - The actor's effects collection
 */
export class EventideRpSystemActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    const flags = actorData.flags.eventiderpsystem || {};
  }

  /**
   *
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic
   * approach is useful when you have actors & items that share a parent Document,
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
  }

  /**
   * Convert the actor document to a plain object.
   *
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   *
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = { ...this };

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

  addResolve(value) {
    this.update({
      "system.resolve.value": clamp(
        this.system.resolve.value + value,
        0,
        this.system.resolve.max
      ),
    });
  }

  addPower(value) {
    this.update({
      "system.power.value": clamp(
        this.system.power.value + value,
        0,
        this.system.power.max
      ),
    });
  }

  async damageResolve({
    formula = "1",
    label = "Damage",
    description = "",
    type = "damage",
    critAllowed = false,
    acCheck = false,
  }) {
    const rollData = {
      formula,
      label,
      type,
      critAllowed,
      description,
      acCheck,
    };
    const roll = await rollHandler(rollData, this);

    // Apply damage to resolve.
    this.addResolve(-roll.total);

    return roll;
  }

  /**
   * Rolls an ability check for the actor with optional advantage or disadvantage.
   *
   * @param {Object} params - Parameters for the ability roll.
   * @param {string} params.ability - The ability to roll.
   * @param {number} [params.advantage=0] - The advantage level for the roll. Positive for advantage, negative for disadvantage.
   * @returns {Promise<Roll>} - The result of the ability roll.
   */
  async rollAbility({ ability, advantage = 0 }) {
    const actorRollData = this.getRollData();
    const isAdvantageRoll = advantage > 0;
    const isDisadvantageRoll = advantage < 0;
    const absAdvantage = Math.abs(advantage);
    const formula = `${absAdvantage + 1}d${
      actorRollData.hiddenAbilities.dice.total
    }${
      isAdvantageRoll
        ? `kh${absAdvantage}`
        : isDisadvantageRoll
        ? `kl${absAdvantage}`
        : ""
    } + ${actorRollData.abilities[ability].total}`;

    const rollData = {
      formula,
      label: `${actorRollData.abilities[ability].label}`,
      type: ability,
    };

    return await rollHandler(rollData, this);
  }

  /**
   * Restores the actor's resources and removes status effects.
   *
   * This function can restore the actor's resolve and power to their maximum values.
   * It can also remove specific status effects or all status effects from the actor.
   *
   * @param {Object} options - The restoration options
   * @param {boolean} options.resolve - Whether to restore resolve to maximum
   * @param {boolean} options.power - Whether to restore power to maximum
   * @param {Array} options.statuses - Array of status effects to be removed
   * @param {boolean} options.all - Whether to remove all status effects
   * @returns {Promise<ChatMessage>} The message detailing the restoration process
   */
  async restore({ resolve, power, statuses, all }) {
    const statusArray =
      statuses?.length && !all
        ? Array.from(statuses)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : all
        ? Array.from(this.items)
            .filter((i) => i.type === "status")
            .map((i) => i.id)
        : [];

    if (resolve) this.addResolve(this.system.resolve.max || 0);
    if (power) this.addPower(this.system.power.max || 0);

    if (statusArray && statusArray.length > 0) {
      const statusIds = Array.from(this.items)
        .filter((i) => i.type === "status" && statusArray.includes(i.id))
        .map((i) => i.id);

      await this.deleteEmbeddedDocuments("Item", statusIds);
    }

    return await restoreMessage({
      all,
      resolve,
      power,
      statuses: statuses
        ? Array.from(statuses).filter((i) => i.type === "status")
        : [],
      actor: this,
    });
  }

  async incrementStatuses({
    statuses = [],
    addAmount = 0,
    overrideAmount = 0,
  }) {
    if (statuses.length === 0 || (addAmount === 0 && overrideAmount === 0))
      return;

    const filteredStatuses = statuses.filter((i) => i.type === "status");

    for (const status of filteredStatuses) {
    }
  }
}
